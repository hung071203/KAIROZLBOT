import { API, Message } from "zca-js";
import { BotContext } from "../types";
import { DeepAiChatStyleEnum, DeepAiModelEnum, DeepAiChatRole } from "../enums";
import { chatDeepAi } from "./chat-ai.service";
import { AccountService, ConfigService } from "../../database/services";
import { IChatDeepAiHistory } from "../types/ai.type";
import removeMarkdown from "remove-markdown";

export interface AgentAction {
  type: "api_call" | "database_query" | "response";
  function?: string;
  parameters?: any;
  description?: string;
}

export interface AgentResponse {
  message: string;
  actions?: AgentAction[];
  needsConfirmation?: boolean;
}

/**
 * Service x·ª≠ l√Ω logic th√¥ng minh cho Agent
 */
export class AgentService {
  private api: API;
  private context: BotContext;
  private event: Message;

  constructor(api: API, context: BotContext, event: Message) {
    this.api = api;
    this.context = context;
    this.event = event;
  }

  /**
   * Ph√¢n t√≠ch y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng v√† x√°c ƒë·ªãnh h√†nh ƒë·ªông c·∫ßn th·ª±c hi·ªán
   */
  async analyzeUserRequest(userInput: string): Promise<AgentResponse> {
    // T·∫°o system prompt v·ªõi c·∫•u h√¨nh agent
    const systemPrompt = `B·∫°n l√† Agent th√¥ng minh c·ªßa KAIROZLBOT - m·ªôt tr·ª£ l√Ω AI c√≥ th·ªÉ th·ª±c hi·ªán c√°c h√†nh ƒë·ªông t·ª± ƒë·ªông tr√™n Zalo.

üîß C√ÅC API ZALO C√ì S·∫¥N (v·ªõi signature chi ti·∫øt):
     ZCA-JS API Documentation

 1. FRIEND MANAGEMENT
// Qu·∫£n l√Ω b·∫°n b√®
api.acceptFriendRequest(userId: string): Promise<"">
api.sendFriendRequest(userId: string, message?: string): Promise<SendFriendRequestResponse>
api.removeFriend(userId: string): Promise<"">
api.blockUser(userId: string): Promise<"">
api.unblockUser(userId: string): Promise<"">
api.changeFriendAlias(alias: string, friendId: string): Promise<"">
api.removeFriendAlias(friendId: string): Promise<"">
api.getAllFriends(count?: number, page?: number): Promise<GetAllFriendsResponse>
// GetAllFriendsResponse: Array<{userId, username, displayName, zaloName, avatar, gender, phoneNumber, status}>


 2. GROUP MANAGEMENT
// Qu·∫£n l√Ω nh√≥m
api.createGroup(options: CreateGroupOptions): Promise<CreateGroupResponse>
// CreateGroupOptions: {name?: string, members: string[], avatarSource?: AttachmentSource}
// CreateGroupResponse: {threadId, sucessMembers, errorMembers, error_data}
api.addUserToGroup(memberId: string | string[], threadId: string): Promise<AddUserToGroupResponse>
api.removeUserFromGroup(memberId: string | string[], threadId: string): Promise<"">
api.changeGroupName(name: string, threadId: string): Promise<ChangeGroupNameResponse>
api.changeGroupAvatar(avatarSource: AttachmentSource, threadId: string): Promise<"">
api.changeGroupOwner(memberId: string, threadId: string): Promise<ChangeGroupOwnerResponse>
api.addGroupDeputy(memberId: string | string[], threadId: string): Promise<"">
api.removeGroupDeputy(memberId: string | string[], threadId: string): Promise<"">
api.leaveGroup(threadId: string): Promise<"">
api.disperseGroup(threadId: string): Promise<"">


 3. MESSAGE APIS
// G·ª≠i tin nh·∫Øn
api.sendMessage(message: MessageContent | string, threadId: string, type?: ThreadType): Promise<SendMessageResponse>
// MessageContent object:
{
  msg: string,                           // N·ªôi dung tin nh·∫Øn (b·∫Øt bu·ªôc)
  styles?: Style[],                      // ƒê·ªãnh d·∫°ng text
  urgency?: Urgency,                     // M·ª©c ƒë·ªô ∆∞u ti√™n (0: Default, 1: Important, 2: Urgent)
  quote?: SendMessageQuote,              // Tr·∫£ l·ªùi tin nh·∫Øn
  mentions?: Mention[],                  // Tag ng∆∞·ªùi d√πng
  attachments?: AttachmentSource[],      // File ƒë√≠nh k√®m
  ttl?: number                          // T·ª± x√≥a (milliseconds)
}

// Style object: {start: number, len: number, st: TextStyle}
// TextStyle: "b"(Bold), "i"(Italic), "u"(Underline), "s"(StrikeThrough), "c_db342e"(Red), "c_f27806"(Orange), "c_f7b503"(Yellow), "c_15a85f"(Green), "f_13"(Small), "f_18"(Big)

// Mention object: {pos: number, uid: string, len: number}

// SendMessageQuote: {content: string, msgType: number, uidFrom: string, msgId: string, cliMsgId: string, ts: number, ttl: number}

// AttachmentSource: string (file path) | {data: Buffer, filename: string, metadata: {totalSize: number, width?: number, height?: number}}

// C√°c API tin nh·∫Øn kh√°c
api.sendSticker(sticker: StickerDetail, threadId: string, type?: ThreadType): Promise<SendStickerResponse>
api.sendVideo(options: SendVideoOptions, threadId: string, type?: ThreadType): Promise<SendVideoResponse>
// SendVideoOptions: {msg?: string, videoUrl: string, thumbnailUrl: string, duration?: number, width?: number, height?: number}

api.sendVoice(options: SendVoiceOptions, threadId: string, type?: ThreadType): Promise<SendVoiceResponse>
// SendVoiceOptions: {voiceUrl: string, ttl?: number}

api.forwardMessage(params: ForwardMessageParams): Promise<ForwardMessageResponse>
// ForwardMessageParams: {message: string, threadIds: string[], ttl?: number, reference?: object}

api.deleteMessage(messageId: string, threadId: string, type?: ThreadType): Promise<"">


4. REACTION & CHAT MANAGEMENT
// Reaction
api.addReaction(icon: Reactions | CustomReaction, dest: AddReactionDestination): Promise<AddReactionResponse>
// AddReactionDestination: {data: {msgId: string, cliMsgId: string}, threadId: string, type: ThreadType}

// Qu·∫£n l√Ω chat
api.deleteChat(threadId: string, type?: ThreadType): Promise<"">
api.setMute(isMute: boolean, threadId: string, type?: ThreadType): Promise<"">
api.addUnreadMark(threadId: string, type?: ThreadType): Promise<AddUnreadMarkResponse>
api.removeUnreadMark(threadId: string, type?: ThreadType): Promise<"">


5. ACCOUNT & USER INFO
// Th√¥ng tin t√†i kho·∫£n
api.fetchAccountInfo(): Promise<AccountInfo>
api.getUserInfo(userId: string | string[]): Promise<ProfileInfo[]>
// ProfileInfo: {displayName, avatar, gender, phoneNumber, ...}

api.changeAccountAvatar(avatarSource: AttachmentSource): Promise<"">
api.updateProfile(profileData: ProfileUpdateData): Promise<"">
// ProfileUpdateData: {displayName?: string, status?: string, ...}
api.getOwnId(): Promise<string>
api.findUser(keyword: string): Promise<FindUserResponse>


6. UTILITIES
// Ti·ªán √≠ch
api.uploadAttachment(attachment: AttachmentSource, threadId: string, type?: ThreadType): Promise<UploadResponse>
api.keepAlive(): Promise<"">

// Tin nh·∫Øn nhanh
api.addQuickMessage(payload: AddQuickMessagePayload): Promise<AddQuickMessageResponse>
// AddQuickMessagePayload: {keyword: string, title: string}
api.getQuickMessage(): Promise<QuickMessageResponse>
api.updateQuickMessage(id: string, payload: UpdateQuickMessagePayload): Promise<"">
// UpdateQuickMessagePayload: {keyword: string, title: string}
api.removeQuickMessage(id: string): Promise<"">

// L·ªùi nh·∫Øc
api.createReminder(reminderData: CreateReminderData): Promise<CreateReminderResponse>
// CreateReminderData: {content: string, time: number, threadId: string}
api.getReminder(reminderId: string): Promise<ReminderInfo>
api.removeReminder(reminderId: string): Promise<"">

// B√¨nh ch·ªçn
api.createPoll(pollData: CreatePollData, threadId: string): Promise<CreatePollResponse>
// CreatePollData: {question: string, options: string[]}
api.getPollDetail(pollId: string): Promise<PollDetailResponse>
api.lockPoll(pollId: string): Promise<"">


7. EVENTS & STATUS
// S·ª± ki·ªán cu·ªôc tr√≤ chuy·ªán
api.sendDeliveredEvent(messageId: string, threadId: string): Promise<"">
api.sendSeenEvent(messageId: string, threadId: string): Promise<"">
api.sendTypingEvent(threadId: string, isTyping: boolean): Promise<"">

// C√†i ƒë·∫∑t
api.updateSettings(settings: SettingsData): Promise<"">
// SettingsData: {
//   notification?: boolean,   // B·∫≠t/t·∫Øt th√¥ng b√°o
//   sound?: boolean,          // B·∫≠t/t·∫Øt √¢m thanh
//   theme?: string,           // Giao di·ªán ("light", "dark", ...)
//   language?: string,        // Ng√¥n ng·ªØ giao di·ªán
//   privacyMode?: boolean,    // ·∫®n tr·∫°ng th√°i ho·∫°t ƒë·ªông
//   autoDownload?: boolean,   // T·ª± ƒë·ªông t·∫£i file
//   [key: string]: any        // C√°c tr∆∞·ªùng m·ªü r·ªông kh√°c
// }
api.updateLang(language: string): Promise<"">

// Sticker
api.getStickers(): Promise<StickersResponse>
api.getStickersDetail(stickerId: string): Promise<StickerDetail>


ENUMS & TYPES
// ThreadType
ThreadType.USER = "USER"           // Chat 1-1
ThreadType.GROUP = "GROUP"         // Chat nh√≥m

// Urgency
Urgency.Default = 0                // Tin nh·∫Øn b√¨nh th∆∞·ªùng
Urgency.Important = 1              // Tin nh·∫Øn quan tr·ªçng
Urgency.Urgent = 2                 // Tin nh·∫Øn kh·∫©n c·∫•p


V√ç D·ª§ S·ª¨ D·ª§NG NHANH
// G·ª≠i tin nh·∫Øn ƒë∆°n gi·∫£n
await api.sendMessage("Hello", "threadId", ThreadType.GROUP);

// G·ª≠i tin nh·∫Øn ph·ª©c t·∫°p
await api.sendMessage({
  msg: "Hello @user, ƒë√¢y l√† tin nh·∫Øn quan tr·ªçng!",
  styles: [{start: 0, len: 5, st: "b"}],
  urgency: 1,
  mentions: [{pos: 6, uid: "userId", len: 5}],
  attachments: ["/path/file.jpg"],
  ttl: 3600000
}, "threadId", ThreadType.GROUP);

// Qu·∫£n l√Ω nh√≥m
await api.createGroup({
  name: "Nh√≥m m·ªõi",
  members: ["user1", "user2"]
});

// Upload v√† g·ª≠i file
const result = await api.uploadAttachment("/path/image.jpg", "threadId");

L∆ØU √ù: EVENT t√¥i g·ª≠i threadId s·∫Ω l√† ID c·ªßa nh√≥m hi·ªán t·∫°i, b·∫°n c√≥ th·ªÉ l·∫•y t·ª´ event.threadId.

üìä C∆† S·ªû D·ªÆ LI·ªÜU:
- accounts: Qu·∫£n l√Ω t√†i kho·∫£n bot
- configs: C·∫•u h√¨nh h·ªá th·ªëng

üìã PH√ÇN T√çCH Y√äU C·∫¶U:
H√£y ph√¢n t√≠ch y√™u c·∫ßu ng∆∞·ªùi d√πng v√† tr·∫£ v·ªÅ JSON v·ªõi format:
{
  "intent": "√Ω ƒë·ªãnh ch√≠nh",
  "actions": [
    {
      "type": "api_call|database_query|response",
      "function": "t√™n_h√†m_api",
      "parameters": { "param1": "value1" },
      "description": "m√¥ t·∫£ h√†nh ƒë·ªông"
    }
  ],
  "response": "ph·∫£n h·ªìi cho ng∆∞·ªùi d√πng",
  "needsConfirmation": true/false
}

H√£y ph√¢n t√≠ch y√™u c·∫ßu ng∆∞·ªùi d√πng v√† ƒë∆∞a ra h√†nh ƒë·ªông ph√π h·ª£p. V√≠ d·ª•:
- "th√¥ng tin nh√≥m n√†y" ‚Üí getGroupInfo
- "th√™m [user] v√†o nh√≥m" ‚Üí addUserToGroup  
- "t·∫°o nh√≥m [t√™n]" ‚Üí createGroup
- "ƒë·ªïi t√™n nh√≥m th√†nh [t√™n]" ‚Üí changeGroupName
- "ai online" ‚Üí getAllFriends + getUserInfo
- "t·∫°o poll [c√¢u h·ªèi]" ‚Üí createPoll`;

    // T·∫°o l·ªãch s·ª≠ m·∫´u ƒë·ªÉ AI hi·ªÉu vai tr√≤
    const agentHistory: IChatDeepAiHistory[] = [
      {
        role: DeepAiChatRole.USER,
        content: systemPrompt,
      },
      {
        role: DeepAiChatRole.ASSISTANT,
        content: `{
  "intent": "nothing",
  "actions": [
    {
      "type": "",
      "function": "",
      "parameters": {
      },
      "description": ""
    }
  ],
  "response": "T√¥i ƒë√£ hi·ªÉu y√™u c·∫ßu c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ h·ªèi t√¥i b·∫•t k·ª≥ c√¢u h·ªèi n√†o li√™n quan ƒë·∫øn Zalo ho·∫∑c y√™u c·∫ßu th·ª±c hi·ªán c√°c h√†nh ƒë·ªông t·ª± ƒë·ªông.",
  "needsConfirmation": false
}`,
      },
      {
        role: DeepAiChatRole.USER,
        content:
          "T√¥i s·∫Ω g·ª≠i cho b·∫°n c√°c s·ª± ki·ªán li√™n quan ƒë·∫øn tin nh·∫Øn. Nhi·ªám v·ª• c·ªßa b·∫°n l√† ph√¢n t√≠ch n·ªôi dung v√† ph·∫£n h·ªìi l·∫°i d∆∞·ªõi d·∫°ng JSON theo ƒë√∫ng c·∫•u tr√∫c m√† t√¥i ƒë√£ c·∫•u h√¨nh tr∆∞·ªõc ƒë√≥. L∆∞u √Ω quan tr·ªçng: b·∫°n ph·∫£i tr·∫£ v·ªÅ k·∫øt qu·∫£ d∆∞·ªõi d·∫°ng JSON h·ª£p l·ªá, kh√¥ng ƒë∆∞·ª£c s·ª≠ d·ª•ng vƒÉn b·∫£n m√¥ t·∫£ trong ph·∫£n h·ªìi.",
      },
      {
        role: DeepAiChatRole.ASSISTANT,
        content: `{
  "intent": "g·ª≠i tin nh·∫Øn",
  "actions": [
    {
      "type": "api_call",
      "function": "sendMessage",
      "parameters": {
        "content": "Hello",
        "threadId": null,
        "type": 1
      },
      "description": "V√¢ng ng√†i"
    }
  ],
  "response": "v√¢ng ng√†i",
  "needsConfirmation": false
}`,
      },
    ];

    try {
      const aiResponse = await chatDeepAi({
        style: DeepAiChatStyleEnum.CHAT,
        content: `${userInput}`,
        model: DeepAiModelEnum.STANDARD,
        history: agentHistory,
      });

      console.log("AI Response:", aiResponse);

      // Parse JSON response t·ª´ AI
      let analysisResult;
      try {
        const removeMarkdownContent = removeMarkdown(aiResponse.content);
        console.log("Remove Markdown Content:", removeMarkdownContent);

        analysisResult = JSON.parse(removeMarkdownContent);
      } catch (parseError) {
        // N·∫øu kh√¥ng parse ƒë∆∞·ª£c JSON, tr·∫£ v·ªÅ response th√¥ng th∆∞·ªùng
        return {
          message: aiResponse.content,
          actions: [
            {
              type: "response",
              description: "Ph·∫£n h·ªìi th√¥ng th∆∞·ªùng",
            },
          ],
        };
      }

      return {
        message: analysisResult.response || "ƒê√£ ph√¢n t√≠ch y√™u c·∫ßu",
        actions: analysisResult.actions || [],
        needsConfirmation: analysisResult.needsConfirmation || false,
      };
    } catch (error: any) {
      console.error("Error analyzing user request:", error);
      return {
        message: `‚ùå L·ªói khi ph√¢n t√≠ch y√™u c·∫ßu: ${error.message}`,
        actions: [],
      };
    }
  }

  /**
   * Th·ª±c thi c√°c h√†nh ƒë·ªông ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch
   */
  async executeActions(actions: AgentAction[]): Promise<string[]> {
    const results: string[] = [];

    for (const action of actions) {
      try {
        let result = "";

        switch (action.type) {
          case "api_call":
            result = await this.executeApiCall(action);
            break;
          case "database_query":
            result = await this.executeDatabaseQuery(action);
            break;
          case "response":
            result = action.description || "ƒê√£ th·ª±c hi·ªán h√†nh ƒë·ªông";
            break;
        }

        results.push(result);
      } catch (error: any) {
        results.push(`‚ùå L·ªói th·ª±c thi ${action.function}: ${error.message}`);
      }
    }

    return results;
  }

  /**
   * Th·ª±c thi API call
   */
  private async executeApiCall(action: AgentAction): Promise<string> {
    const { function: fnName, parameters = {} } = action;

    try {
      switch (fnName) {
        // TH√îNG TIN NG∆Ø·ªúI D√ôNG & NH√ìM
        case "getUserInfo":
          const userInfo = await this.api.getUserInfo(parameters.userId);
          const profile = userInfo.changed_profiles?.[parameters.userId];
          return profile
            ? `üë§ ${profile.displayName || profile.username} (${
                profile.userId
              })`
            : `‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin user ${parameters.userId}`;

        case "getGroupInfo":
          const groupResponse = await this.api.getGroupInfo(
            parameters.threadId || this.event.threadId
          );
          const groupInfo =
            groupResponse.gridInfoMap?.[
              parameters.threadId || this.event.threadId
            ];
          return groupInfo
            ? `üë• Nh√≥m: ${groupInfo.name}\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Th√†nh vi√™n: ${
                groupInfo.totalMember
              }\nüëë Admin: ${groupInfo.adminIds?.length || 0} ng∆∞·ªùi`
            : `‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√≥m`;

        case "findUser":
          const foundUser = await this.api.findUser(parameters.phoneNumber);
          return `üîç T√¨m th·∫•y: ${foundUser.display_name} (${foundUser.uid})`;

        case "fetchAccountInfo":
          const accountInfo = await this.api.fetchAccountInfo();
          return `üì± Th√¥ng tin t√†i kho·∫£n bot ƒë√£ ƒë∆∞·ª£c l·∫•y`;

        case "getOwnId":
          const ownId = await this.api.getOwnId();
          return `ü§ñ Bot ID: ${ownId}`;

        case "getGroupMembersInfo":
          const membersInfo = await this.api.getGroupMembersInfo(
            parameters.threadId || this.event.threadId
          );
          const memberCount = Object.keys(membersInfo.profiles || {}).length;
          return `üë• C√≥ ${memberCount} th√†nh vi√™n trong nh√≥m`;

        case "getAllFriends":
          const friends = await this.api.getAllFriends(
            parameters.count,
            parameters.page
          );
          const friendCount = Array.isArray(friends) ? friends.length : 0;
          return `üë´ B·∫°n c√≥ ${friendCount} b·∫°n b√®`;

        case "getAllGroups":
          const groups = await this.api.getAllGroups();
          const groupCount = groups.gridInfoMap
            ? Object.keys(groups.gridInfoMap).length
            : 0;
          return `üë• B·∫°n tham gia ${groupCount} nh√≥m`;

        // G·ª¨I TIN NH·∫ÆN & N·ªòI DUNG
        case "sendMessage":
          const messageContent =
            typeof parameters.content === "string"
              ? parameters.content
              : {
                  msg: parameters.content || parameters.message,
                  styles: parameters.styles,
                  urgency: parameters.urgency,
                  mentions: parameters.mentions,
                  attachments: parameters.attachments,
                  ttl: parameters.ttl,
                };

          await this.api.sendMessage(
            messageContent,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn`;

        case "sendCard":
          await this.api.sendCard(
            {
              userId: parameters.userId,
              phoneNumber: parameters.phoneNumber,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i card ng∆∞·ªùi d√πng`;

        case "sendLink":
          await this.api.sendLink(
            {
              msg: parameters.msg,
              link: parameters.link,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i link`;

        case "sendVideo":
          await this.api.sendVideo(
            {
              msg: parameters.msg,
              videoUrl: parameters.videoUrl,
              thumbnailUrl: parameters.thumbnailUrl,
              duration: parameters.duration,
              width: parameters.width,
              height: parameters.height,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i video`;

        case "sendVoice":
          await this.api.sendVoice(
            {
              voiceUrl: parameters.voiceUrl,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i voice message`;

        case "forwardMessage":
          const forwardResult = await this.api.forwardMessage(
            {
              message: parameters.message,
              threadIds: parameters.threadIds || [this.event.threadId],
              ttl: parameters.ttl,
              reference: parameters.reference,
            },
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ forward tin nh·∫Øn t·ªõi ${forwardResult.success.length} cu·ªôc tr√≤ chuy·ªán`;

        case "uploadAttachment":
          const uploadResult = await this.api.uploadAttachment(
            parameters.attachment,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ upload attachment`;

        // QU·∫¢N L√ù NH√ìM N√ÇNG CAO
        case "createGroup":
          const newGroup = await this.api.createGroup({
            name: parameters.name,
            members: parameters.members || [],
            avatarSource: parameters.avatarSource,
          });
          return `‚úÖ ƒê√£ t·∫°o nh√≥m: ${parameters.name} (ID: ${newGroup.groupId})`;

        case "changeGroupName":
          await this.api.changeGroupName(
            parameters.name,
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ ƒë·ªïi t√™n nh√≥m th√†nh: ${parameters.name}`;

        case "changeGroupAvatar":
          await this.api.changeGroupAvatar(
            parameters.avatarSource,
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ ƒë·ªïi avatar nh√≥m`;

        case "addUserToGroup":
          const addResult = await this.api.addUserToGroup(
            parameters.userId,
            parameters.threadId || this.event.threadId
          );
          if (addResult.errorMembers && addResult.errorMembers.length > 0) {
            return `‚ö†Ô∏è C√≥ l·ªói khi th√™m m·ªôt s·ªë th√†nh vi√™n: ${addResult.errorMembers.join(
              ", "
            )}`;
          }
          return `‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng v√†o nh√≥m`;

        case "removeUserFromGroup":
          await this.api.removeUserFromGroup(
            parameters.userId,
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ x√≥a ng∆∞·ªùi d√πng kh·ªèi nh√≥m`;

        case "changeGroupOwner":
          const ownerResult = await this.api.changeGroupOwner(
            parameters.memberId,
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ chuy·ªÉn quy·ªÅn admin ch√≠nh`;

        case "addGroupDeputy":
          await this.api.addGroupDeputy(
            parameters.userId,
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ th√™m ph√≥ admin`;

        case "removeGroupDeputy":
          await this.api.removeGroupDeputy(
            parameters.userId,
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ x√≥a ph√≥ admin`;

        case "leaveGroup":
          const leaveResult = await this.api.leaveGroup(
            parameters.threadId || this.event.threadId,
            parameters.silent || false
          );
          return `‚úÖ ƒê√£ r·ªùi kh·ªèi nh√≥m`;

        case "disperseGroup":
          await this.api.disperseGroup(
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ gi·∫£i t√°n nh√≥m`;

        case "inviteUserToGroups":
          const inviteResult = await this.api.inviteUserToGroups(
            parameters.memberId,
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ m·ªùi ng∆∞·ªùi d√πng v√†o nh√≥m`;

        case "joinGroup":
          await this.api.joinGroup(parameters.link);
          return `‚úÖ ƒê√£ tham gia nh√≥m t·ª´ link`;

        case "enableGroupLink":
          await this.api.enableGroupLink(
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ b·∫≠t link m·ªùi nh√≥m`;

        case "disableGroupLink":
          await this.api.disableGroupLink(
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ t·∫Øt link m·ªùi nh√≥m`;

        // B·∫†N B√à & K·∫æT N·ªêI N√ÇNG CAO
        case "sendFriendRequest":
          await this.api.sendFriendRequest(
            parameters.message || "Xin ch√†o!",
            parameters.userId
          );
          return `‚úÖ ƒê√£ g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n`;

        case "acceptFriendRequest":
          await this.api.acceptFriendRequest(parameters.userId);
          return `‚úÖ ƒê√£ ch·∫•p nh·∫≠n l·ªùi m·ªùi k·∫øt b·∫°n`;

        case "removeFriend":
          await this.api.removeFriend(parameters.friendId);
          return `‚úÖ ƒê√£ x√≥a b·∫°n`;

        case "blockUser":
          await this.api.blockUser(parameters.userId);
          return `‚úÖ ƒê√£ ch·∫∑n ng∆∞·ªùi d√πng`;

        case "unblockUser":
          await this.api.unblockUser(parameters.userId);
          return `‚úÖ ƒê√£ b·ªè ch·∫∑n ng∆∞·ªùi d√πng`;

        case "changeFriendAlias":
          await this.api.changeFriendAlias(
            parameters.alias,
            parameters.friendId
          );
          return `‚úÖ ƒê√£ ƒë·ªïi t√™n hi·ªÉn th·ªã b·∫°n b√® th√†nh: ${parameters.alias}`;

        case "getReceivedFriendRequests":
          const receivedRequests = await this.api.getReceivedFriendRequests();
          return `üì® C√≥ l·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ nh·∫≠n`;

        case "getSentFriendRequest":
          const sentRequests = await this.api.getSentFriendRequest();
          return `üì§ C√≥ l·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ g·ª≠i`;

        case "undoFriendRequest":
          await this.api.undoFriendRequest(parameters.userId);
          return `‚úÖ ƒê√£ h·ªßy l·ªùi m·ªùi k·∫øt b·∫°n`;

        // TIN NH·∫ÆN & T∆Ø∆†NG T√ÅC N√ÇNG CAO
        case "addReaction":
          // addReaction c·∫ßn AddReactionDestination object
          const reactionDest = {
            data: {
              msgId: parameters.messageId || parameters.msgId,
              cliMsgId: parameters.cliMsgId || parameters.messageId,
            },
            threadId: parameters.threadId || this.event.threadId,
            type: parameters.type || (this.event.type === 0 ? 0 : 1),
          };
          await this.api.addReaction(parameters.reaction || "üëç", reactionDest);
          return `‚úÖ ƒê√£ th·∫£ c·∫£m x√∫c`;

        case "deleteMessage":
          // deleteMessage c·∫ßn DeleteMessageDestination object
          const deleteDest = {
            data: {
              cliMsgId: parameters.cliMsgId || parameters.messageId,
              msgId: parameters.messageId || parameters.msgId,
              uidFrom: parameters.uidFrom || this.event.data.uidFrom,
            },
            threadId: parameters.threadId || this.event.threadId,
            type: parameters.type || (this.event.type === 0 ? 0 : 1),
          };
          await this.api.deleteMessage(deleteDest, parameters.onlyMe || false);
          return `‚úÖ ƒê√£ x√≥a tin nh·∫Øn`;

        case "undo":
          await this.api.undo(
            {
              msgId: parameters.msgId,
              cliMsgId: parameters.cliMsgId,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ ho√†n t√°c tin nh·∫Øn`;

        case "sendTypingEvent":
          await this.api.sendTypingEvent(
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1),
            parameters.destType
          );
          return `‚úÖ ƒê√£ hi·ªÉn th·ªã ƒëang g√µ`;

        // POLL & B√åNH CH·ªåN
        case "createPoll":
          const pollResult = await this.api.createPoll(
            {
              question: parameters.question,
              options: parameters.options || ["C√≥", "Kh√¥ng"],
              expiredTime: parameters.expiredTime,
              allowMultiChoices: parameters.allowMultiChoices,
              allowAddNewOption: parameters.allowAddNewOption,
              hideVotePreview: parameters.hideVotePreview,
              isAnonymous: parameters.isAnonymous,
            },
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ t·∫°o poll: ${parameters.question}`;

        case "getPollDetail":
          const pollDetail = await this.api.getPollDetail(parameters.pollId);
          return `üìä Poll: ${pollDetail.question} (${pollDetail.options.length} l·ª±a ch·ªçn)`;

        case "lockPoll":
          await this.api.lockPoll(parameters.pollId);
          return `üîí ƒê√£ kh√≥a poll`;

        // NH·∫ÆC NH·ªû
        case "createReminder":
          await this.api.createReminder(
            {
              title: parameters.title,
              emoji: parameters.emoji,
              startTime: parameters.startTime || Date.now() + 3600000,
              repeat: parameters.repeat,
            },
            parameters.threadId || this.event.threadId
          );
          return `‚è∞ ƒê√£ t·∫°o nh·∫Øc nh·ªü: ${parameters.title}`;

        case "getListReminder":
          const reminders = await this.api.getListReminder(
            { page: parameters.page || 1, count: parameters.count || 10 },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `üìã ƒê√£ l·∫•y danh s√°ch nh·∫Øc nh·ªü`;

        case "editReminder":
          await this.api.editReminder(
            parameters.reminderId,
            parameters.options
          );
          return `‚úÖ ƒê√£ s·ª≠a nh·∫Øc nh·ªü`;

        case "removeReminder":
          await this.api.removeReminder(
            parameters.reminderId,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ x√≥a nh·∫Øc nh·ªü`;

        // C√ÄI ƒê·∫∂T & QU·∫¢N L√ù
        case "updateProfile":
          await this.api.updateProfile(
            parameters.name,
            parameters.dateOfBirth || "1990-01-01",
            parameters.gender || 1
          );
          return `‚úÖ ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n`;

        case "changeAccountAvatar":
          await this.api.changeAccountAvatar(parameters.avatarSource);
          return `‚úÖ ƒê√£ ƒë·ªïi avatar t√†i kho·∫£n`;

        case "setMute":
          await this.api.setMute(
            parameters.threadId || this.event.threadId,
            parameters.muteInfo
          );
          return `üîá ƒê√£ t·∫Øt th√¥ng b√°o`;

        case "getMute":
          const muteList = await this.api.getMute();
          return `üîá ƒê√£ l·∫•y danh s√°ch t·∫Øt th√¥ng b√°o`;

        case "setPinnedConversations":
          await this.api.setPinnedConversations(
            parameters.pinned !== false,
            parameters.threadIds || parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `üìå ƒê√£ ghim cu·ªôc tr√≤ chuy·ªán`;

        case "getPinConversations":
          const pinnedList = await this.api.getPinConversations();
          return `üìå ƒê√£ l·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán ƒë√£ ghim`;

        case "setHiddenConversations":
          await this.api.setHiddenConversations(
            parameters.hidden !== false,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ ·∫©n cu·ªôc tr√≤ chuy·ªán`;

        case "getHiddenConversations":
          const hiddenList = await this.api.getHiddenConversations();
          return `üôà ƒê√£ l·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán ƒë√£ ·∫©n`;

        // TI·ªÜN √çCH & KH√ÅC
        case "parseLink":
          const linkInfo = await this.api.parseLink(parameters.url);
          return `üîó ƒê√£ ph√¢n t√≠ch link`;

        case "getStickers":
          const stickerList = await this.api.getStickers(
            parameters.keyword || ""
          );
          return `üòÑ ƒê√£ l·∫•y danh s√°ch sticker`;

        case "getStickersDetail":
          const stickerDetails = await this.api.getStickersDetail(
            parameters.stickerIds
          );
          return `üòÑ ƒê√£ l·∫•y chi ti·∫øt ${stickerDetails.length} sticker`;

        case "keepAlive":
          await this.api.keepAlive();
          return `üíì ƒê√£ duy tr√¨ k·∫øt n·ªëi`;

        case "lastOnline":
          const lastOnlineInfo = await this.api.lastOnline(parameters.userId);
          return `üïê ƒê√£ ki·ªÉm tra l·∫ßn online cu·ªëi`;

        case "custom":
          const customResult = await this.api.custom(
            parameters.apiName,
            parameters.params
          );
          return `üîß ƒê√£ th·ª±c thi API t√πy ch·ªânh: ${parameters.apiName}`;

        default:
          throw new Error(`‚ùå Kh√¥ng t√¨m th·∫•y API: ${fnName}`);
      }
    } catch (error) {
      console.error(`‚ùå L·ªói khi th·ª±c thi API ${fnName}:`, error);
      throw error;
    }
  }

  /**
   * Th·ª±c thi database query
   */
  private async executeDatabaseQuery(action: AgentAction): Promise<string> {
    if (!this.context.db) {
      throw new Error("Database kh√¥ng kh·∫£ d·ª•ng");
    }

    const { function: query, parameters = {} } = action;

    try {
      switch (query) {
        case "get_accounts":
          const accountService = new AccountService();
          const accounts = await accountService.getActiveAccounts();
          return `üìä C√≥ ${accounts.length} t√†i kho·∫£n ƒëang ho·∫°t ƒë·ªông`;

        case "get_account_info":
          const accountService2 = new AccountService();
          const account = await accountService2.getAccountById(
            parameters.accountId
          );
          return account
            ? `üì± T√†i kho·∫£n: ${account.accountId} (${account.loginMethod})`
            : `‚ùå Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n`;

        case "get_configs":
          const configService = new ConfigService();
          const configs = await configService.getAllConfigs();
          return `‚öôÔ∏è C√≥ ${Object.keys(configs).length} c·∫•u h√¨nh trong h·ªá th·ªëng`;

        default:
          throw new Error(`Kh√¥ng h·ªó tr·ª£ database query: ${query}`);
      }
    } catch (error: any) {
      throw new Error(`L·ªói database ${query}: ${error.message}`);
    }
  }

  /**
   * X·ª≠ l√Ω y√™u c·∫ßu ch√≠nh
   */
  async processRequest(userInput: string): Promise<string> {
    try {
      // Ki·ªÉm tra n·∫øu l√† l·ªánh x√°c nh·∫≠n
      if (this.isConfirmationCommand(userInput)) {
        return this.handleConfirmation();
      }

      // Ph√¢n t√≠ch y√™u c·∫ßu
      const analysis = await this.analyzeUserRequest(userInput);

      // N·∫øu c·∫ßn x√°c nh·∫≠n, h·ªèi ng∆∞·ªùi d√πng tr∆∞·ªõc
      if (
        analysis.needsConfirmation &&
        analysis.actions &&
        analysis.actions.length > 0
      ) {
        // L∆∞u pending actions v√†o context ƒë·ªÉ x·ª≠ l√Ω sau
        this.storePendingActions(analysis.actions);

        const actionDescriptions = analysis.actions
          .map(
            (action) =>
              `üî∏ ${action.function || action.type}: ${
                action.description || "Th·ª±c hi·ªán h√†nh ƒë·ªông"
              }`
          )
          .join("\n");

        return `ü§î T√¥i s·∫Ω th·ª±c hi·ªán c√°c h√†nh ƒë·ªông sau:\n${actionDescriptions}\n\n‚ùì B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c kh√¥ng? (Tr·∫£ l·ªùi "c√≥", "yes", "ƒë·ªìng √Ω" ƒë·ªÉ x√°c nh·∫≠n)`;
      }

      // Th·ª±c thi c√°c h√†nh ƒë·ªông
      if (analysis.actions && analysis.actions.length > 0) {
        const results = await this.executeActions(analysis.actions);
        const combinedResults = results.join("\n");

        return `${analysis.message}\n\nüìã K·∫øt qu·∫£ th·ª±c thi:\n${combinedResults}`;
      }

      return analysis.message;
    } catch (error: any) {
      console.error("Error processing request:", error);
      return `‚ùå L·ªói x·ª≠ l√Ω y√™u c·∫ßu: ${error.message}`;
    }
  }

  /**
   * Ki·ªÉm tra xem c√≥ ph·∫£i l·ªánh x√°c nh·∫≠n kh√¥ng
   */
  private isConfirmationCommand(input: string): boolean {
    const confirmationWords = [
      "c√≥",
      "yes",
      "ok",
      "ƒë·ªìng √Ω",
      "x√°c nh·∫≠n",
      "ti·∫øp t·ª•c",
      "ƒë∆∞·ª£c",
      "go",
    ];
    return confirmationWords.some(
      (word) =>
        input.toLowerCase().trim() === word ||
        input.toLowerCase().includes(word)
    );
  }

  /**
   * L∆∞u pending actions (gi·∫£ l·∫≠p - trong th·ª±c t·∫ø c·∫ßn l∆∞u v√†o database ho·∫∑c cache)
   */
  private storePendingActions(actions: AgentAction[]): void {
    // Trong th·ª±c t·∫ø, b·∫°n c√≥ th·ªÉ l∆∞u v√†o database v·ªõi userId v√† threadId
    // ·ªû ƒë√¢y ch√∫ng ta ch·ªâ log ƒë·ªÉ demo
    console.log("Pending actions stored:", actions);
  }

  /**
   * X·ª≠ l√Ω x√°c nh·∫≠n (gi·∫£ l·∫≠p)
   */
  private async handleConfirmation(): Promise<string> {
    // Trong th·ª±c t·∫ø, l·∫•y pending actions t·ª´ database
    return "‚úÖ T√≠nh nƒÉng x√°c nh·∫≠n ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn. Hi·ªán t·∫°i c√°c h√†nh ƒë·ªông s·∫Ω ƒë∆∞·ª£c th·ª±c thi ngay l·∫≠p t·ª©c.";
  }
}
