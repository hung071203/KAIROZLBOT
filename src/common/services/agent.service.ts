import { API, Message } from "zca-js";
import { BotContext } from "../types";
import { DeepAiChatStyleEnum, DeepAiModelEnum, DeepAiChatRole } from "../enums";
import { chatDeepAi } from "./chat-ai.service";
import { AccountService, ConfigService } from "../../database/services";
import { IChatDeepAiHistory } from "../types/ai.type";

export interface AgentAction {
  type: "api_call" | "database_query" | "response";
  function?: string;
  parameters?: any;
  description?: string;
}

export interface AgentResponse {
  message: string;
  actions?: AgentAction[];
  needsConfirmation?: boolean;
}

/**
 * Service x·ª≠ l√Ω logic th√¥ng minh cho Agent
 */
export class AgentService {
  private api: API;
  private context: BotContext;
  private event: Message;

  constructor(api: API, context: BotContext, event: Message) {
    this.api = api;
    this.context = context;
    this.event = event;
  }

  /**
   * Ph√¢n t√≠ch y√™u c·∫ßu c·ªßa ng∆∞·ªùi d√πng v√† x√°c ƒë·ªãnh h√†nh ƒë·ªông c·∫ßn th·ª±c hi·ªán
   */
  async analyzeUserRequest(userInput: string): Promise<AgentResponse> {
    // T·∫°o system prompt v·ªõi c·∫•u h√¨nh agent
    const systemPrompt = `B·∫°n l√† Agent th√¥ng minh c·ªßa KAIROZLBOT - m·ªôt tr·ª£ l√Ω AI c√≥ th·ªÉ th·ª±c hi·ªán c√°c h√†nh ƒë·ªông t·ª± ƒë·ªông tr√™n Zalo.

üîß C√ÅC API ZALO C√ì S·∫¥N (v·ªõi signature chi ti·∫øt):

1. TH√îNG TIN NG∆Ø·ªúI D√ôNG & NH√ìM:
   - getUserInfo(userId): L·∫•y th√¥ng tin chi ti·∫øt ng∆∞·ªùi d√πng
   - getGroupInfo(groupId): L·∫•y th√¥ng tin nh√≥m (t√™n, s·ªë th√†nh vi√™n, admin...)
   - getGroupMembersInfo(groupId): L·∫•y danh s√°ch th√†nh vi√™n nh√≥m
   - getAllFriends(count?, page?): L·∫•y danh s√°ch b·∫°n b√® v·ªõi ph√¢n trang
   - getAllGroups(): L·∫•y danh s√°ch t·∫•t c·∫£ nh√≥m
   - findUser(phoneNumber): T√¨m ng∆∞·ªùi d√πng b·∫±ng s·ªë ƒëi·ªán tho·∫°i
   - fetchAccountInfo(): L·∫•y th√¥ng tin t√†i kho·∫£n hi·ªán t·∫°i
   - getOwnId(): L·∫•y ID c·ªßa t√†i kho·∫£n bot

2. G·ª¨I TIN NH·∫ÆN & N·ªòI DUNG:
   - sendMessage(messageContent|string, threadId, type?): G·ª≠i tin nh·∫Øn v·ªõi formatting
   - sendCard(options, threadId, type?): G·ª≠i card ng∆∞·ªùi d√πng
     * options: {userId, phoneNumber?, ttl?}
   - sendLink(options, threadId, type?): G·ª≠i link v·ªõi preview
     * options: {msg?, link, ttl?}
   - sendVideo(options, threadId, type?): G·ª≠i video
     * options: {msg?, videoUrl, thumbnailUrl, duration?, width?, height?, ttl?}
   - sendVoice(options, threadId, type?): G·ª≠i voice message
     * options: {voiceUrl, ttl?}
   - forwardMessage(params, type?): Forward tin nh·∫Øn t·ªõi nhi·ªÅu thread
     * params: {message, threadIds[], ttl?, reference?}
   - uploadAttachment(attachment, threadId, type?): Upload file/·∫£nh/video

3. QU·∫¢N L√ù NH√ìM:
   - createGroup(options): T·∫°o nh√≥m m·ªõi {name, members[], avatarSource?}
   - changeGroupName(name, groupId): ƒê·ªïi t√™n nh√≥m
   - changeGroupAvatar(avatarSource, groupId): ƒê·ªïi avatar nh√≥m
   - addUserToGroup(userId|userId[], groupId): Th√™m ng∆∞·ªùi v√†o nh√≥m
   - removeUserFromGroup(userId, groupId): X√≥a ng∆∞·ªùi kh·ªèi nh√≥m
   - changeGroupOwner(memberId, groupId): Chuy·ªÉn quy·ªÅn admin ch√≠nh
   - addGroupDeputy(userId, groupId): Th√™m ph√≥ admin
   - removeGroupDeputy(userId, groupId): X√≥a ph√≥ admin
   - leaveGroup(groupId|groupIds[], silent?): R·ªùi kh·ªèi nh√≥m
   - disperseGroup(groupId): Gi·∫£i t√°n nh√≥m (ch·ªâ admin ch√≠nh)
   - inviteUserToGroups(memberId, groupId|groupIds[]): M·ªùi v√†o nhi·ªÅu nh√≥m
   - joinGroup(link): Tham gia nh√≥m b·∫±ng link
   - enableGroupLink(groupId): B·∫≠t link m·ªùi nh√≥m
   - disableGroupLink(groupId): T·∫Øt link m·ªùi nh√≥m
   - getGroupLinkInfo(link): L·∫•y th√¥ng tin t·ª´ link nh√≥m

4. B·∫†N B√à & K·∫æT N·ªêI:
   - sendFriendRequest(message, userId): G·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n
   - acceptFriendRequest(userId): Ch·∫•p nh·∫≠n l·ªùi m·ªùi k·∫øt b·∫°n
   - removeFriend(friendId): X√≥a b·∫°n
   - blockUser(userId): Ch·∫∑n ng∆∞·ªùi d√πng
   - unblockUser(userId): B·ªè ch·∫∑n ng∆∞·ªùi d√πng
   - changeFriendAlias(alias, friendId): ƒê·ªïi t√™n hi·ªÉn th·ªã b·∫°n b√®
   - getReceivedFriendRequests(): L·∫•y danh s√°ch l·ªùi m·ªùi nh·∫≠n ƒë∆∞·ª£c
   - getSentFriendRequest(): L·∫•y danh s√°ch l·ªùi m·ªùi ƒë√£ g·ª≠i
   - undoFriendRequest(userId): H·ªßy l·ªùi m·ªùi k·∫øt b·∫°n

5. TIN NH·∫ÆN & T∆Ø∆†NG T√ÅC:
   - addReaction(reaction, destination): Th·∫£ c·∫£m x√∫c
     * destination: {data: {msgId, cliMsgId}, threadId, type}
   - deleteMessage(destination, onlyMe?): X√≥a tin nh·∫Øn
     * destination: {data: {msgId, cliMsgId, uidFrom}, threadId, type}
   - undo(payload, threadId, type?): Ho√†n t√°c tin nh·∫Øn
     * payload: {msgId, cliMsgId}
   - sendTypingEvent(threadId, type?, destType?): Hi·ªÉn th·ªã ƒëang g√µ
   - sendSeenEvent(messageId): ƒê√°nh d·∫•u ƒë√£ xem
   - sendDeliveredEvent(messageId): ƒê√°nh d·∫•u ƒë√£ nh·∫≠n

6. POLL & B√åNH CH·ªåN:
   - createPoll(pollOptions, groupId): T·∫°o poll b√¨nh ch·ªçn
     * pollOptions: {question, options[], expiredTime?, allowMultiChoices?, allowAddNewOption?, hideVotePreview?, isAnonymous?}
   - getPollDetail(pollId): L·∫•y chi ti·∫øt poll
   - lockPoll(pollId): Kh√≥a poll

7. NH·∫ÆC NH·ªû & L·ªäCH TR√åNH:
   - createReminder(reminderOptions, threadId, type?): T·∫°o nh·∫Øc nh·ªü
     * reminderOptions: {title, emoji?, startTime?, repeat?}
   - getListReminder(): L·∫•y danh s√°ch nh·∫Øc nh·ªü
   - editReminder(reminderId, options): S·ª≠a nh·∫Øc nh·ªü
   - removeReminder(reminderId): X√≥a nh·∫Øc nh·ªü

8. C√ÄI ƒê·∫∂T & QU·∫¢N L√ù:
   - updateProfile(profileInfo): C·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n
   - changeAccountAvatar(avatarSource): ƒê·ªïi avatar t√†i kho·∫£n
   - setMute(threadId, muteInfo): T·∫Øt th√¥ng b√°o
   - getMute(): L·∫•y danh s√°ch ƒë√£ t·∫Øt th√¥ng b√°o
   - setPinnedConversations(threadIds[]): Ghim cu·ªôc tr√≤ chuy·ªán
   - getPinConversations(): L·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán ƒë√£ ghim
   - setHiddenConversations(threadIds[]): ·∫®n cu·ªôc tr√≤ chuy·ªán
   - getHiddenConversations(): L·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán ƒë√£ ·∫©n

9. TI·ªÜN √çCH & KH√ÅC:
   - parseLink(url): Ph√¢n t√≠ch link
   - getStickers(): L·∫•y danh s√°ch sticker
   - getStickersDetail(stickerIds[]): L·∫•y chi ti·∫øt sticker
   - keepAlive(): Duy tr√¨ k·∫øt n·ªëi
   - lastOnline(userId): Ki·ªÉm tra l·∫ßn online cu·ªëi
   - custom(apiName, params): G·ªçi API t√πy ch·ªânh

8. C√ÄI ƒê·∫∂T & QU·∫¢N L√ù:
   - updateProfile(profileInfo): C·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n
   - changeAccountAvatar(avatar): ƒê·ªïi avatar t√†i kho·∫£n
   - setMute(threadId, muteInfo): T·∫Øt th√¥ng b√°o
   - getMute(): L·∫•y danh s√°ch ƒë√£ t·∫Øt th√¥ng b√°o
   - setPinnedConversations(threadIds): Ghim cu·ªôc tr√≤ chuy·ªán
   - getPinConversations(): L·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán ƒë√£ ghim

üìä C∆† S·ªû D·ªÆ LI·ªÜU:
- accounts: Qu·∫£n l√Ω t√†i kho·∫£n bot
- configs: C·∫•u h√¨nh h·ªá th·ªëng

üìã PH√ÇN T√çCH Y√äU C·∫¶U:
H√£y ph√¢n t√≠ch y√™u c·∫ßu ng∆∞·ªùi d√πng v√† tr·∫£ v·ªÅ JSON v·ªõi format:
{
  "intent": "√Ω ƒë·ªãnh ch√≠nh",
  "actions": [
    {
      "type": "api_call|database_query|response",
      "function": "t√™n_h√†m_api",
      "parameters": { "param1": "value1" },
      "description": "m√¥ t·∫£ h√†nh ƒë·ªông"
    }
  ],
  "response": "ph·∫£n h·ªìi cho ng∆∞·ªùi d√πng",
  "needsConfirmation": true/false
}

H√£y ph√¢n t√≠ch y√™u c·∫ßu ng∆∞·ªùi d√πng v√† ƒë∆∞a ra h√†nh ƒë·ªông ph√π h·ª£p. V√≠ d·ª•:
- "th√¥ng tin nh√≥m n√†y" ‚Üí getGroupInfo
- "th√™m [user] v√†o nh√≥m" ‚Üí addUserToGroup  
- "t·∫°o nh√≥m [t√™n]" ‚Üí createGroup
- "ƒë·ªïi t√™n nh√≥m th√†nh [t√™n]" ‚Üí changeGroupName
- "ai online" ‚Üí getAllFriends + getUserInfo
- "t·∫°o poll [c√¢u h·ªèi]" ‚Üí createPoll`;

    // T·∫°o l·ªãch s·ª≠ m·∫´u ƒë·ªÉ AI hi·ªÉu vai tr√≤
    const agentHistory: IChatDeepAiHistory[] = [
      {
        role: DeepAiChatRole.USER,
        content: systemPrompt,
      },
      {
        role: DeepAiChatRole.ASSISTANT,
        content: `{
  "intent": "nothing",
  "actions": [
    {
      "type": "",
      "function": "",
      "parameters": {
      },
      "description": ""
    }
  ],
  "response": "T√¥i ƒë√£ hi·ªÉu y√™u c·∫ßu c·ªßa b·∫°n. B·∫°n c√≥ th·ªÉ h·ªèi t√¥i b·∫•t k·ª≥ c√¢u h·ªèi n√†o li√™n quan ƒë·∫øn Zalo ho·∫∑c y√™u c·∫ßu th·ª±c hi·ªán c√°c h√†nh ƒë·ªông t·ª± ƒë·ªông.",
  "needsConfirmation": false
}`,
      },
      {
        role: DeepAiChatRole.USER,
        content: "agent g·ª≠i tin nh·∫Øn Hello cho nh√≥m",
      },
      {
        role: DeepAiChatRole.ASSISTANT,
        content: `{
  "intent": "g·ª≠i tin nh·∫Øn",
  "actions": [
    {
      "type": "api_call",
      "function": "sendMessage",
      "parameters": {
        "content": "Hello",
        "threadId": null,
        "type": 1
      },
      "description": "G·ª≠i tin nh·∫Øn 'Hello' cho nh√≥m hi·ªán t·∫°i"
    }
  ],
  "response": "ƒê√£ g·ª≠i tin nh·∫Øn 'Hello' cho nh√≥m",
  "needsConfirmation": false
}`,
      },
    ];

    try {
      const aiResponse = await chatDeepAi({
        style: DeepAiChatStyleEnum.CHAT,
        content: `ƒê·ªçc ng·ªØ c·∫£nh v√† ph·∫£n h·ªìi theo c√°c d·ªØ ki·ªán t√¥i ƒë√£ c·∫•p:${userInput}`,
        model: DeepAiModelEnum.STANDARD,
        history: agentHistory,
      });

      console.log("AI Response:", aiResponse);
      
      // Parse JSON response t·ª´ AI
      let analysisResult;
      try {
        // T√¨m JSON trong response
        const jsonMatch = aiResponse.content.match(/\{[\s\S]*?\}$/);
        if (jsonMatch) {
          analysisResult = JSON.parse(jsonMatch[0]);
        } else {
          // N·∫øu kh√¥ng c√≥ JSON, t√¨m c√°ch kh√°c
          const lines = aiResponse.content.split("\n");
          const jsonLine = lines.find((line) => line.trim().startsWith("{"));
          if (jsonLine) {
            analysisResult = JSON.parse(jsonLine.trim());
          } else {
            throw new Error("No JSON found");
          }
        }
      } catch (parseError) {
        console.log("AI Response:", aiResponse.content);
        // N·∫øu kh√¥ng parse ƒë∆∞·ª£c JSON, tr·∫£ v·ªÅ response th√¥ng th∆∞·ªùng
        return {
          message: aiResponse.content,
          actions: [
            {
              type: "response",
              description: "Ph·∫£n h·ªìi th√¥ng th∆∞·ªùng",
            },
          ],
        };
      }

      return {
        message: analysisResult.response || "ƒê√£ ph√¢n t√≠ch y√™u c·∫ßu",
        actions: analysisResult.actions || [],
        needsConfirmation: analysisResult.needsConfirmation || false,
      };
    } catch (error: any) {
      console.error("Error analyzing user request:", error);
      return {
        message: `‚ùå L·ªói khi ph√¢n t√≠ch y√™u c·∫ßu: ${error.message}`,
        actions: [],
      };
    }
  }

  /**
   * Th·ª±c thi c√°c h√†nh ƒë·ªông ƒë√£ ƒë∆∞·ª£c ph√¢n t√≠ch
   */
  async executeActions(actions: AgentAction[]): Promise<string[]> {
    const results: string[] = [];

    for (const action of actions) {
      try {
        let result = "";

        switch (action.type) {
          case "api_call":
            result = await this.executeApiCall(action);
            break;
          case "database_query":
            result = await this.executeDatabaseQuery(action);
            break;
          case "response":
            result = action.description || "ƒê√£ th·ª±c hi·ªán h√†nh ƒë·ªông";
            break;
        }

        results.push(result);
      } catch (error: any) {
        results.push(`‚ùå L·ªói th·ª±c thi ${action.function}: ${error.message}`);
      }
    }

    return results;
  }

  /**
   * Th·ª±c thi API call
   */
  private async executeApiCall(action: AgentAction): Promise<string> {
    const { function: fnName, parameters = {} } = action;

    try {
      switch (fnName) {
        // TH√îNG TIN NG∆Ø·ªúI D√ôNG & NH√ìM
        case "getUserInfo":
          const userInfo = await this.api.getUserInfo(parameters.userId);
          const profile = userInfo.changed_profiles?.[parameters.userId];
          return profile
            ? `üë§ ${profile.displayName || profile.username} (${
                profile.userId
              })`
            : `‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin user ${parameters.userId}`;

        case "getGroupInfo":
          const groupResponse = await this.api.getGroupInfo(
            parameters.groupId || this.event.threadId
          );
          const groupInfo =
            groupResponse.gridInfoMap?.[
              parameters.groupId || this.event.threadId
            ];
          return groupInfo
            ? `üë• Nh√≥m: ${groupInfo.name}\nüë®‚Äçüë©‚Äçüëß‚Äçüë¶ Th√†nh vi√™n: ${
                groupInfo.totalMember
              }\nüëë Admin: ${groupInfo.adminIds?.length || 0} ng∆∞·ªùi`
            : `‚ùå Kh√¥ng t√¨m th·∫•y th√¥ng tin nh√≥m`;

        case "findUser":
          const foundUser = await this.api.findUser(parameters.phoneNumber);
          return `üîç T√¨m th·∫•y: ${foundUser.display_name} (${foundUser.uid})`;

        case "fetchAccountInfo":
          const accountInfo = await this.api.fetchAccountInfo();
          return `üì± Th√¥ng tin t√†i kho·∫£n bot ƒë√£ ƒë∆∞·ª£c l·∫•y`;

        case "getOwnId":
          const ownId = await this.api.getOwnId();
          return `ü§ñ Bot ID: ${ownId}`;

        case "getGroupMembersInfo":
          const membersInfo = await this.api.getGroupMembersInfo(
            parameters.groupId || this.event.threadId
          );
          const memberCount = Object.keys(membersInfo.profiles || {}).length;
          return `üë• C√≥ ${memberCount} th√†nh vi√™n trong nh√≥m`;

        case "getAllFriends":
          const friends = await this.api.getAllFriends(
            parameters.count,
            parameters.page
          );
          const friendCount = Array.isArray(friends) ? friends.length : 0;
          return `üë´ B·∫°n c√≥ ${friendCount} b·∫°n b√®`;

        case "getAllGroups":
          const groups = await this.api.getAllGroups();
          const groupCount = groups.gridInfoMap
            ? Object.keys(groups.gridInfoMap).length
            : 0;
          return `üë• B·∫°n tham gia ${groupCount} nh√≥m`;

        // G·ª¨I TIN NH·∫ÆN & N·ªòI DUNG
        case "sendMessage":
          const messageContent =
            typeof parameters.content === "string"
              ? parameters.content
              : {
                  msg: parameters.content || parameters.message,
                  styles: parameters.styles,
                  urgency: parameters.urgency,
                  mentions: parameters.mentions,
                  attachments: parameters.attachments,
                  ttl: parameters.ttl,
                };

          await this.api.sendMessage(
            messageContent,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i tin nh·∫Øn`;

        case "sendCard":
          await this.api.sendCard(
            {
              userId: parameters.userId,
              phoneNumber: parameters.phoneNumber,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i card ng∆∞·ªùi d√πng`;

        case "sendLink":
          await this.api.sendLink(
            {
              msg: parameters.msg,
              link: parameters.link,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i link`;

        case "sendVideo":
          await this.api.sendVideo(
            {
              msg: parameters.msg,
              videoUrl: parameters.videoUrl,
              thumbnailUrl: parameters.thumbnailUrl,
              duration: parameters.duration,
              width: parameters.width,
              height: parameters.height,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i video`;

        case "sendVoice":
          await this.api.sendVoice(
            {
              voiceUrl: parameters.voiceUrl,
              ttl: parameters.ttl,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ g·ª≠i voice message`;

        case "forwardMessage":
          const forwardResult = await this.api.forwardMessage(
            {
              message: parameters.message,
              threadIds: parameters.threadIds || [this.event.threadId],
              ttl: parameters.ttl,
              reference: parameters.reference,
            },
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ forward tin nh·∫Øn t·ªõi ${forwardResult.success.length} cu·ªôc tr√≤ chuy·ªán`;

        case "uploadAttachment":
          const uploadResult = await this.api.uploadAttachment(
            parameters.attachment,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ upload attachment`;

        // QU·∫¢N L√ù NH√ìM N√ÇNG CAO
        case "createGroup":
          const newGroup = await this.api.createGroup({
            name: parameters.name,
            members: parameters.members || [],
            avatarSource: parameters.avatarSource,
          });
          return `‚úÖ ƒê√£ t·∫°o nh√≥m: ${parameters.name} (ID: ${newGroup.groupId})`;

        case "changeGroupName":
          await this.api.changeGroupName(
            parameters.name,
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ ƒë·ªïi t√™n nh√≥m th√†nh: ${parameters.name}`;

        case "changeGroupAvatar":
          await this.api.changeGroupAvatar(
            parameters.avatarSource,
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ ƒë·ªïi avatar nh√≥m`;

        case "addUserToGroup":
          const addResult = await this.api.addUserToGroup(
            parameters.userId,
            parameters.groupId || this.event.threadId
          );
          if (addResult.errorMembers && addResult.errorMembers.length > 0) {
            return `‚ö†Ô∏è C√≥ l·ªói khi th√™m m·ªôt s·ªë th√†nh vi√™n: ${addResult.errorMembers.join(
              ", "
            )}`;
          }
          return `‚úÖ ƒê√£ th√™m ng∆∞·ªùi d√πng v√†o nh√≥m`;

        case "removeUserFromGroup":
          await this.api.removeUserFromGroup(
            parameters.userId,
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ x√≥a ng∆∞·ªùi d√πng kh·ªèi nh√≥m`;

        case "changeGroupOwner":
          const ownerResult = await this.api.changeGroupOwner(
            parameters.memberId,
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ chuy·ªÉn quy·ªÅn admin ch√≠nh`;

        case "addGroupDeputy":
          await this.api.addGroupDeputy(
            parameters.userId,
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ th√™m ph√≥ admin`;

        case "removeGroupDeputy":
          await this.api.removeGroupDeputy(
            parameters.userId,
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ x√≥a ph√≥ admin`;

        case "leaveGroup":
          const leaveResult = await this.api.leaveGroup(
            parameters.groupId || this.event.threadId,
            parameters.silent || false
          );
          return `‚úÖ ƒê√£ r·ªùi kh·ªèi nh√≥m`;

        case "disperseGroup":
          await this.api.disperseGroup(
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ gi·∫£i t√°n nh√≥m`;

        case "inviteUserToGroups":
          const inviteResult = await this.api.inviteUserToGroups(
            parameters.memberId,
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ m·ªùi ng∆∞·ªùi d√πng v√†o nh√≥m`;

        case "joinGroup":
          await this.api.joinGroup(parameters.link);
          return `‚úÖ ƒê√£ tham gia nh√≥m t·ª´ link`;

        case "enableGroupLink":
          await this.api.enableGroupLink(
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ b·∫≠t link m·ªùi nh√≥m`;

        case "disableGroupLink":
          await this.api.disableGroupLink(
            parameters.groupId || this.event.threadId
          );
          return `‚úÖ ƒê√£ t·∫Øt link m·ªùi nh√≥m`;

        // B·∫†N B√à & K·∫æT N·ªêI N√ÇNG CAO
        case "sendFriendRequest":
          await this.api.sendFriendRequest(
            parameters.message || "Xin ch√†o!",
            parameters.userId
          );
          return `‚úÖ ƒê√£ g·ª≠i l·ªùi m·ªùi k·∫øt b·∫°n`;

        case "acceptFriendRequest":
          await this.api.acceptFriendRequest(parameters.userId);
          return `‚úÖ ƒê√£ ch·∫•p nh·∫≠n l·ªùi m·ªùi k·∫øt b·∫°n`;

        case "removeFriend":
          await this.api.removeFriend(parameters.friendId);
          return `‚úÖ ƒê√£ x√≥a b·∫°n`;

        case "blockUser":
          await this.api.blockUser(parameters.userId);
          return `‚úÖ ƒê√£ ch·∫∑n ng∆∞·ªùi d√πng`;

        case "unblockUser":
          await this.api.unblockUser(parameters.userId);
          return `‚úÖ ƒê√£ b·ªè ch·∫∑n ng∆∞·ªùi d√πng`;

        case "changeFriendAlias":
          await this.api.changeFriendAlias(
            parameters.alias,
            parameters.friendId
          );
          return `‚úÖ ƒê√£ ƒë·ªïi t√™n hi·ªÉn th·ªã b·∫°n b√® th√†nh: ${parameters.alias}`;

        case "getReceivedFriendRequests":
          const receivedRequests = await this.api.getReceivedFriendRequests();
          return `üì® C√≥ l·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ nh·∫≠n`;

        case "getSentFriendRequest":
          const sentRequests = await this.api.getSentFriendRequest();
          return `üì§ C√≥ l·ªùi m·ªùi k·∫øt b·∫°n ƒë√£ g·ª≠i`;

        case "undoFriendRequest":
          await this.api.undoFriendRequest(parameters.userId);
          return `‚úÖ ƒê√£ h·ªßy l·ªùi m·ªùi k·∫øt b·∫°n`;

        // TIN NH·∫ÆN & T∆Ø∆†NG T√ÅC N√ÇNG CAO
        case "addReaction":
          // addReaction c·∫ßn AddReactionDestination object
          const reactionDest = {
            data: {
              msgId: parameters.messageId || parameters.msgId,
              cliMsgId: parameters.cliMsgId || parameters.messageId,
            },
            threadId: parameters.threadId || this.event.threadId,
            type: parameters.type || (this.event.type === 0 ? 0 : 1),
          };
          await this.api.addReaction(parameters.reaction || "üëç", reactionDest);
          return `‚úÖ ƒê√£ th·∫£ c·∫£m x√∫c`;

        case "deleteMessage":
          // deleteMessage c·∫ßn DeleteMessageDestination object
          const deleteDest = {
            data: {
              cliMsgId: parameters.cliMsgId || parameters.messageId,
              msgId: parameters.messageId || parameters.msgId,
              uidFrom: parameters.uidFrom || this.event.data.uidFrom,
            },
            threadId: parameters.threadId || this.event.threadId,
            type: parameters.type || (this.event.type === 0 ? 0 : 1),
          };
          await this.api.deleteMessage(deleteDest, parameters.onlyMe || false);
          return `‚úÖ ƒê√£ x√≥a tin nh·∫Øn`;

        case "undo":
          await this.api.undo(
            {
              msgId: parameters.msgId,
              cliMsgId: parameters.cliMsgId,
            },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ ho√†n t√°c tin nh·∫Øn`;

        case "sendTypingEvent":
          await this.api.sendTypingEvent(
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1),
            parameters.destType
          );
          return `‚úÖ ƒê√£ hi·ªÉn th·ªã ƒëang g√µ`;

        // POLL & B√åNH CH·ªåN
        case "createPoll":
          const pollResult = await this.api.createPoll(
            {
              question: parameters.question,
              options: parameters.options || ["C√≥", "Kh√¥ng"],
              expiredTime: parameters.expiredTime,
              allowMultiChoices: parameters.allowMultiChoices,
              allowAddNewOption: parameters.allowAddNewOption,
              hideVotePreview: parameters.hideVotePreview,
              isAnonymous: parameters.isAnonymous,
            },
            parameters.threadId || this.event.threadId
          );
          return `‚úÖ ƒê√£ t·∫°o poll: ${parameters.question}`;

        case "getPollDetail":
          const pollDetail = await this.api.getPollDetail(parameters.pollId);
          return `üìä Poll: ${pollDetail.question} (${pollDetail.options.length} l·ª±a ch·ªçn)`;

        case "lockPoll":
          await this.api.lockPoll(parameters.pollId);
          return `üîí ƒê√£ kh√≥a poll`;

        // NH·∫ÆC NH·ªû
        case "createReminder":
          await this.api.createReminder(
            {
              title: parameters.title,
              emoji: parameters.emoji,
              startTime: parameters.startTime || Date.now() + 3600000,
              repeat: parameters.repeat,
            },
            parameters.threadId || this.event.threadId
          );
          return `‚è∞ ƒê√£ t·∫°o nh·∫Øc nh·ªü: ${parameters.title}`;

        case "getListReminder":
          const reminders = await this.api.getListReminder(
            { page: parameters.page || 1, count: parameters.count || 10 },
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `üìã ƒê√£ l·∫•y danh s√°ch nh·∫Øc nh·ªü`;

        case "editReminder":
          await this.api.editReminder(
            parameters.reminderId,
            parameters.options
          );
          return `‚úÖ ƒê√£ s·ª≠a nh·∫Øc nh·ªü`;

        case "removeReminder":
          await this.api.removeReminder(
            parameters.reminderId,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ x√≥a nh·∫Øc nh·ªü`;

        // C√ÄI ƒê·∫∂T & QU·∫¢N L√ù
        case "updateProfile":
          await this.api.updateProfile(
            parameters.name,
            parameters.dateOfBirth || "1990-01-01",
            parameters.gender || 1
          );
          return `‚úÖ ƒê√£ c·∫≠p nh·∫≠t th√¥ng tin c√° nh√¢n`;

        case "changeAccountAvatar":
          await this.api.changeAccountAvatar(parameters.avatarSource);
          return `‚úÖ ƒê√£ ƒë·ªïi avatar t√†i kho·∫£n`;

        case "setMute":
          await this.api.setMute(
            parameters.threadId || this.event.threadId,
            parameters.muteInfo
          );
          return `üîá ƒê√£ t·∫Øt th√¥ng b√°o`;

        case "getMute":
          const muteList = await this.api.getMute();
          return `üîá ƒê√£ l·∫•y danh s√°ch t·∫Øt th√¥ng b√°o`;

        case "setPinnedConversations":
          await this.api.setPinnedConversations(
            parameters.pinned !== false,
            parameters.threadIds || parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `üìå ƒê√£ ghim cu·ªôc tr√≤ chuy·ªán`;

        case "getPinConversations":
          const pinnedList = await this.api.getPinConversations();
          return `üìå ƒê√£ l·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán ƒë√£ ghim`;

        case "setHiddenConversations":
          await this.api.setHiddenConversations(
            parameters.hidden !== false,
            parameters.threadId || this.event.threadId,
            parameters.type || (this.event.type === 0 ? 0 : 1)
          );
          return `‚úÖ ƒê√£ ·∫©n cu·ªôc tr√≤ chuy·ªán`;

        case "getHiddenConversations":
          const hiddenList = await this.api.getHiddenConversations();
          return `üôà ƒê√£ l·∫•y danh s√°ch cu·ªôc tr√≤ chuy·ªán ƒë√£ ·∫©n`;

        // TI·ªÜN √çCH & KH√ÅC
        case "parseLink":
          const linkInfo = await this.api.parseLink(parameters.url);
          return `üîó ƒê√£ ph√¢n t√≠ch link`;

        case "getStickers":
          const stickerList = await this.api.getStickers(
            parameters.keyword || ""
          );
          return `üòÑ ƒê√£ l·∫•y danh s√°ch sticker`;

        case "getStickersDetail":
          const stickerDetails = await this.api.getStickersDetail(
            parameters.stickerIds
          );
          return `üòÑ ƒê√£ l·∫•y chi ti·∫øt ${stickerDetails.length} sticker`;

        case "keepAlive":
          await this.api.keepAlive();
          return `üíì ƒê√£ duy tr√¨ k·∫øt n·ªëi`;

        case "lastOnline":
          const lastOnlineInfo = await this.api.lastOnline(parameters.userId);
          return `üïê ƒê√£ ki·ªÉm tra l·∫ßn online cu·ªëi`;

        case "custom":
          const customResult = await this.api.custom(
            parameters.apiName,
            parameters.params
          );
          return `üîß ƒê√£ th·ª±c thi API t√πy ch·ªânh: ${parameters.apiName}`;

        default:
          throw new Error(`‚ùå Kh√¥ng t√¨m th·∫•y API: ${fnName}`);
      }
    } catch (error) {
      console.error(`‚ùå L·ªói khi th·ª±c thi API ${fnName}:`, error);
      throw error;
    }
  }

  /**
   * Th·ª±c thi database query
   */
  private async executeDatabaseQuery(action: AgentAction): Promise<string> {
    if (!this.context.db) {
      throw new Error("Database kh√¥ng kh·∫£ d·ª•ng");
    }

    const { function: query, parameters = {} } = action;

    try {
      switch (query) {
        case "get_accounts":
          const accountService = new AccountService();
          const accounts = await accountService.getActiveAccounts();
          return `üìä C√≥ ${accounts.length} t√†i kho·∫£n ƒëang ho·∫°t ƒë·ªông`;

        case "get_account_info":
          const accountService2 = new AccountService();
          const account = await accountService2.getAccountById(
            parameters.accountId
          );
          return account
            ? `üì± T√†i kho·∫£n: ${account.accountId} (${account.loginMethod})`
            : `‚ùå Kh√¥ng t√¨m th·∫•y t√†i kho·∫£n`;

        case "get_configs":
          const configService = new ConfigService();
          const configs = await configService.getAllConfigs();
          return `‚öôÔ∏è C√≥ ${Object.keys(configs).length} c·∫•u h√¨nh trong h·ªá th·ªëng`;

        default:
          throw new Error(`Kh√¥ng h·ªó tr·ª£ database query: ${query}`);
      }
    } catch (error: any) {
      throw new Error(`L·ªói database ${query}: ${error.message}`);
    }
  }

  /**
   * X·ª≠ l√Ω y√™u c·∫ßu ch√≠nh
   */
  async processRequest(userInput: string): Promise<string> {
    try {
      // Ki·ªÉm tra n·∫øu l√† l·ªánh x√°c nh·∫≠n
      if (this.isConfirmationCommand(userInput)) {
        return this.handleConfirmation();
      }

      // Ph√¢n t√≠ch y√™u c·∫ßu
      const analysis = await this.analyzeUserRequest(userInput);
      
      // N·∫øu c·∫ßn x√°c nh·∫≠n, h·ªèi ng∆∞·ªùi d√πng tr∆∞·ªõc
      if (
        analysis.needsConfirmation &&
        analysis.actions &&
        analysis.actions.length > 0
      ) {
        // L∆∞u pending actions v√†o context ƒë·ªÉ x·ª≠ l√Ω sau
        this.storePendingActions(analysis.actions);

        const actionDescriptions = analysis.actions
          .map(
            (action) =>
              `üî∏ ${action.function || action.type}: ${
                action.description || "Th·ª±c hi·ªán h√†nh ƒë·ªông"
              }`
          )
          .join("\n");

        return `ü§î T√¥i s·∫Ω th·ª±c hi·ªán c√°c h√†nh ƒë·ªông sau:\n${actionDescriptions}\n\n‚ùì B·∫°n c√≥ mu·ªën ti·∫øp t·ª•c kh√¥ng? (Tr·∫£ l·ªùi "c√≥", "yes", "ƒë·ªìng √Ω" ƒë·ªÉ x√°c nh·∫≠n)`;
      }

      // Th·ª±c thi c√°c h√†nh ƒë·ªông
      if (analysis.actions && analysis.actions.length > 0) {
        const results = await this.executeActions(analysis.actions);
        const combinedResults = results.join("\n");

        return `${analysis.message}\n\nüìã K·∫øt qu·∫£ th·ª±c thi:\n${combinedResults}`;
      }

      return analysis.message;
    } catch (error: any) {
      console.error("Error processing request:", error);
      return `‚ùå L·ªói x·ª≠ l√Ω y√™u c·∫ßu: ${error.message}`;
    }
  }

  /**
   * Ki·ªÉm tra xem c√≥ ph·∫£i l·ªánh x√°c nh·∫≠n kh√¥ng
   */
  private isConfirmationCommand(input: string): boolean {
    const confirmationWords = [
      "c√≥",
      "yes",
      "ok",
      "ƒë·ªìng √Ω",
      "x√°c nh·∫≠n",
      "ti·∫øp t·ª•c",
      "ƒë∆∞·ª£c",
      "go",
    ];
    return confirmationWords.some(
      (word) =>
        input.toLowerCase().trim() === word ||
        input.toLowerCase().includes(word)
    );
  }

  /**
   * L∆∞u pending actions (gi·∫£ l·∫≠p - trong th·ª±c t·∫ø c·∫ßn l∆∞u v√†o database ho·∫∑c cache)
   */
  private storePendingActions(actions: AgentAction[]): void {
    // Trong th·ª±c t·∫ø, b·∫°n c√≥ th·ªÉ l∆∞u v√†o database v·ªõi userId v√† threadId
    // ·ªû ƒë√¢y ch√∫ng ta ch·ªâ log ƒë·ªÉ demo
    console.log("Pending actions stored:", actions);
  }

  /**
   * X·ª≠ l√Ω x√°c nh·∫≠n (gi·∫£ l·∫≠p)
   */
  private async handleConfirmation(): Promise<string> {
    // Trong th·ª±c t·∫ø, l·∫•y pending actions t·ª´ database
    return "‚úÖ T√≠nh nƒÉng x√°c nh·∫≠n ƒëang ƒë∆∞·ª£c ph√°t tri·ªÉn. Hi·ªán t·∫°i c√°c h√†nh ƒë·ªông s·∫Ω ƒë∆∞·ª£c th·ª±c thi ngay l·∫≠p t·ª©c.";
  }
}
